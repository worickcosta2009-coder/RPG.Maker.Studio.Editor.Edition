<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>RPG Maker Studio - Editor Edition</title>
    <style>
        :root { --bg: #181818; --panel: #202020; --accent: #007acc; --text: #d4d4d4; --border: #333; --select-color: rgba(0, 122, 204, 0.3); }
        body { background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; margin: 0; padding: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; user-select: none; }
        
        /* CSS ICONS */
        .icon-undo::before { content: "‚Ü©"; margin-right:5px;}
        .icon-upload::before { content: "üìÇ"; margin-right:5px;}
        .icon-save::before { content: "üíæ"; margin-right:5px;}
        .icon-edit::before { content: "‚úèÔ∏è"; margin-right:5px;}

        /* Toolbar */
        .toolbar { background: var(--panel); padding: 8px 15px; display: flex; gap: 15px; align-items: center; border-bottom: 1px solid var(--border); flex-wrap: wrap; z-index: 100; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .group { display: flex; align-items: center; gap: 8px; border-right: 1px solid var(--border); padding-right: 15px; }
        .group:last-child { border: none; }
        
        label { font-size: 10px; font-weight: bold; color: #888; text-transform: uppercase; display: block; margin-bottom: 2px; }
        
        select, input { background: #333; border: 1px solid #555; color: white; padding: 4px; border-radius: 3px; font-size: 12px; }
        input[type="number"] { width: 45px; text-align: center; }
        
        button { background: #333; color: #eee; border: 1px solid #555; padding: 5px 12px; border-radius: 3px; cursor: pointer; font-size: 12px; font-weight: 600; display: flex; align-items: center; }
        button:hover { background: #444; border-color: #666; }
        button:active { transform: translateY(1px); }
        button.primary { background: var(--accent); color: white; border: none; }
        button.primary:hover { filter: brightness(1.1); }
        
        /* Workspace */
        .workspace { flex: 1; display: flex; overflow: hidden; }
        .pane { flex: 1; display: flex; flex-direction: column; min-width: 0; border-right: 2px solid var(--border); position: relative; }
        
        .pane-header { 
            background: #252526; padding: 6px 10px; font-size: 11px; color: #aaa; font-weight: bold; 
            display: flex; justify-content: space-between; border-bottom: 1px solid var(--border);
        }
        
        .canvas-wrapper { 
            flex: 1; overflow: auto; background: #111; position: relative; 
            display: grid; place-items: center;
        }

        /* Fundos */
        .bg-grid {
            background-image: linear-gradient(45deg, #222 25%, transparent 25%), linear-gradient(-45deg, #222 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #222 75%), linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px;
        }

        canvas { 
            image-rendering: pixelated; 
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            display: block;
        }

        /* Mouse Styles */
        #srcCanvas { cursor: crosshair; }
        #destCanvas { cursor: none; } /* Custom ghost cursor */

        .statusbar { background: var(--accent); color: white; padding: 2px 10px; font-size: 11px; display: flex; justify-content: space-between; font-weight: bold; }
        
        /* Input File escondido */
        .hidden-upload { display: none; }
    </style>
</head>
<body>

    <!-- TOOLBAR -->
    <div class="toolbar">
        <div class="group">
            <div>
                <label>Modo</label>
                <select id="modeSelect" onchange="App.setMode(this.value)">
                    <option value="tileset">Tileset (Mapas)</option>
                    <option value="char">Characters / Sprites</option>
                    <option value="faceset">Faceset</option>
                    <option value="free">Livre / Battler</option>
                </select>
            </div>
        </div>

        <div class="group">
            <div>
                <label>Grade (Snap)</label>
                <div style="display:flex; gap:5px">
                    <input type="number" id="gridW" value="32" onchange="App.updateGrid()" title="Largura">
                    <input type="number" id="gridH" value="32" onchange="App.updateGrid()" title="Altura">
                </div>
            </div>
            <div>
                <label>Zoom</label>
                <input type="range" min="1" max="4" step="0.5" value="1" oninput="App.setZoom(this.value)" style="width:70px">
            </div>
        </div>

        <div class="group">
            <button onclick="App.undo()"><span class="icon-undo"></span> Desfazer</button>
        </div>

        <div class="group" style="margin-left: auto; border:none;">
            <!-- Uploads -->
            <button onclick="document.getElementById('uplSrc').click()"><span class="icon-upload"></span> Carregar Origem</button>
            <button onclick="document.getElementById('uplDest').click()" style="border: 1px solid #007acc; color: #007acc"><span class="icon-edit"></span> Editar Tileset Existente</button>
            <button class="primary" onclick="App.download()"><span class="icon-save"></span> Baixar Final</button>
            
            <input type="file" id="uplSrc" class="hidden-upload" accept="image/*" onchange="App.handleUpload(this, 'src')">
            <input type="file" id="uplDest" class="hidden-upload" accept="image/*" onchange="App.handleUpload(this, 'dest')">
        </div>
    </div>

    <!-- WORKSPACE -->
    <div class="workspace">
        <!-- ORIGEM (ESQUERDA) -->
        <div class="pane">
            <div class="pane-header">
                <span>ORIGEM</span> 
                <span style="color:#007acc">Arraste para selecionar v√°rios</span>
            </div>
            <div class="canvas-wrapper bg-grid" id="srcWrapper">
                <canvas id="srcCanvas"></canvas>
            </div>
        </div>

        <!-- DESTINO (DIREITA) -->
        <div class="pane">
            <div class="pane-header">
                <span>DESTINO</span> 
                <span>Clique para colar</span>
            </div>
            <div class="canvas-wrapper bg-grid" id="destWrapper">
                <canvas id="destCanvas"></canvas>
            </div>
        </div>
    </div>

    <div class="statusbar">
        <span id="statusText">Dica: Carregue um Tileset na direita para editar, ou um em branco para criar.</span>
        <span id="coords">0, 0</span>
    </div>

    <script>
        const App = {
            state: {
                gridW: 32, gridH: 32,
                zoom: 1,
                isSelecting: false, // Se est√° arrastando na origem
                selStart: {x:0, y:0}, // Onde come√ßou o clique
                selRect: {x:0, y:0, w:0, h:0}, // Ret√¢ngulo final da sele√ß√£o
                clipboard: null, // Bitmap copiado
                history: [],
                historyIndex: -1
            },
            
            els: {},

            init() {
                // Mapear elementos
                ['srcCanvas', 'destCanvas', 'srcWrapper', 'destWrapper', 'gridW', 'gridH'].forEach(id => this.els[id] = document.getElementById(id));
                
                this.els.srcCtx = this.els.srcCanvas.getContext('2d', { willReadFrequently: true });
                this.els.destCtx = this.els.destCanvas.getContext('2d', { willReadFrequently: true });
                
                // Configura√ß√£o inicial
                this.els.srcCtx.imageSmoothingEnabled = false;
                this.els.destCtx.imageSmoothingEnabled = false;
                
                this.setupEvents();
                this.setMode('tileset');
                this.initDest(512, 512); // Tamanho padr√£o Tileset
            },

            // --- CONFIGURA√á√ÉO ---
            setMode(mode) {
                let w=32, h=32;
                if(mode === 'faceset') { w=96; h=96; }
                if(mode === 'free') { w=1; h=1; }
                
                this.els.gridW.value = w;
                this.els.gridH.value = h;
                this.updateGrid();
            },

            updateGrid() {
                this.state.gridW = parseInt(this.els.gridW.value) || 32;
                this.state.gridH = parseInt(this.els.gridH.value) || 32;
                this.redrawSource(); // Redesenha a grade na origem
            },

            initDest(w, h) {
                this.els.destCanvas.width = w;
                this.els.destCanvas.height = h;
                this.els.destCtx.imageSmoothingEnabled = false;
                this.saveHistory();
                this.redrawDest();
            },

            // --- DESENHO ---
            redrawSource() {
                if(!this.els.srcImg) return;
                const ctx = this.els.srcCtx;
                const w = this.els.srcCanvas.width;
                const h = this.els.srcCanvas.height;

                // 1. Imagem Limpa
                ctx.clearRect(0,0,w,h);
                ctx.drawImage(this.els.srcImg, 0, 0);

                // 2. Grade Base (Fina, Cinza)
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.lineWidth = 1;
                for(let x=0; x<=w; x+=this.state.gridW) { ctx.moveTo(x,0); ctx.lineTo(x,h); }
                for(let y=0; y<=h; y+=this.state.gridH) { ctx.moveTo(0,y); ctx.lineTo(w,y); }
                ctx.stroke();

                // 3. Ret√¢ngulo de Sele√ß√£o (Se estiver selecionando)
                if (this.state.selRect.w > 0) {
                    ctx.fillStyle = 'rgba(0, 122, 204, 0.3)';
                    ctx.strokeStyle = '#00e5ff';
                    ctx.lineWidth = 2;
                    const r = this.state.selRect;
                    ctx.fillRect(r.x, r.y, r.w, r.h);
                    ctx.strokeRect(r.x, r.y, r.w, r.h);
                }
            },

            redrawDest(ghostX, ghostY) {
                const ctx = this.els.destCtx;
                
                // 1. Restaurar Hist√≥rico
                if(this.state.history[this.state.historyIndex]) {
                    ctx.putImageData(this.state.history[this.state.historyIndex], 0, 0);
                } else {
                    ctx.clearRect(0,0, this.els.destCanvas.width, this.els.destCanvas.height);
                }

                // 2. Grade (Opcional, s√≥ pra guiar)
                // (Omitido para ficar mais limpo na visualiza√ß√£o do editor)

                // 3. Fantasma (Preview do que vai colar)
                if(this.state.clipboard && ghostX !== undefined) {
                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    ctx.drawImage(this.state.clipboard, ghostX, ghostY);
                    
                    // Borda do Fantasma
                    ctx.strokeStyle = '#00e5ff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(ghostX, ghostY, this.state.selRect.w, this.state.selRect.h);
                    ctx.restore();
                }
            },

            // --- EVENTOS DE ORIGEM (SELE√á√ÉO INTELIGENTE) ---
            setupEvents() {
                const src = this.els.srcCanvas;
                
                // MOUSE DOWN: Come√ßa sele√ß√£o
                src.onmousedown = (e) => {
                    if(!this.els.srcImg) return;
                    this.state.isSelecting = true;
                    
                    const pos = this.getGridPos(src, e);
                    this.state.selStart = pos; // Guarda onde clicou
                    
                    // Inicializa rect com tamanho de 1 c√©lula
                    this.state.selRect = { x: pos.x, y: pos.y, w: this.state.gridW, h: this.state.gridH };
                    this.redrawSource();
                };

                // MOUSE MOVE: Expande sele√ß√£o
                src.onmousemove = (e) => {
                    if(!this.state.isSelecting) return;
                    
                    const current = this.getGridPos(src, e);
                    const start = this.state.selStart;
                    
                    // Calcula ret√¢ngulo baseado no arrastar
                    // Math.min/max permite arrastar para tr√°s (esquerda/cima)
                    const x = Math.min(start.x, current.x);
                    const y = Math.min(start.y, current.y);
                    // A largura deve incluir a c√©lula onde o mouse est√°
                    const w = Math.abs(current.x - start.x) + this.state.gridW; 
                    const h = Math.abs(current.y - start.y) + this.state.gridH;

                    this.state.selRect = { x, y, w, h };
                    this.redrawSource();
                };

                // MOUSE UP: Finaliza e Copia
                window.addEventListener('mouseup', () => {
                    if(this.state.isSelecting) {
                        this.state.isSelecting = false;
                        this.copySelection();
                    }
                });

                // --- EVENTOS DE DESTINO ---
                const dest = this.els.destCanvas;
                
                dest.onmousemove = (e) => {
                    // O fantasma deve seguir o mouse, mas alinhado √† grade
                    const pos = this.getGridPos(dest, e);
                    this.redrawDest(pos.x, pos.y);
                    document.getElementById('coords').innerText = `X: ${pos.x}, Y: ${pos.y}`;
                };
                
                dest.onmouseleave = () => this.redrawDest();

                dest.onmousedown = (e) => {
                    if(!this.state.clipboard) return;
                    const pos = this.getGridPos(dest, e);
                    
                    if(e.button === 0) { // Colar
                        // Limpa a √°rea antes de colar (pra n√£o sobrepor transpar√™ncia sujando)
                        // this.els.destCtx.clearRect(pos.x, pos.y, this.state.selRect.w, this.state.selRect.h);
                        // NA VERDADE: Como estamos editando, queremos sobrepor (Painter's Algorithm). 
                        // Se quiser apagar antes, descomente a linha acima.
                        
                        this.els.destCtx.drawImage(this.state.clipboard, pos.x, pos.y);
                        this.saveHistory();
                        this.redrawDest(pos.x, pos.y);
                        this.status("Colado!");
                    } else if(e.button === 2) { // Borracha
                        this.els.destCtx.clearRect(pos.x, pos.y, this.state.selRect.w, this.state.selRect.h);
                        this.saveHistory();
                        this.redrawDest(pos.x, pos.y);
                    }
                };
                dest.oncontextmenu = e => e.preventDefault();
            },

            // Auxiliar para pegar coordenada na grade
            getGridPos(canvas, e) {
                const rect = canvas.getBoundingClientRect();
                const scale = this.state.zoom;
                const rawX = (e.clientX - rect.left) / scale;
                const rawY = (e.clientY - rect.top) / scale;
                
                // Arredonda para baixo pelo tamanho da grade
                const x = Math.floor(rawX / this.state.gridW) * this.state.gridW;
                const y = Math.floor(rawY / this.state.gridH) * this.state.gridH;
                return { x, y };
            },

            copySelection() {
                if(!this.els.srcImg) return;
                const r = this.state.selRect;
                
                // Extrai da imagem original (limpa)
                this.els.srcCtx.drawImage(this.els.srcImg, 0, 0); // Remove overlay visual
                const data = this.els.srcCtx.getImageData(r.x, r.y, r.w, r.h);
                this.redrawSource(); // Devolve overlay

                createImageBitmap(data).then(bmp => {
                    this.state.clipboard = bmp;
                    this.status(`Copiada √°rea de ${r.w}x${r.h} pixels.`);
                });
            },

            // --- ARQUIVOS E HIST√ìRICO ---
            handleUpload(input, target) {
                if(!input.files[0]) return;
                const img = new Image();
                img.onload = () => {
                    if(target === 'src') {
                        this.els.srcImg = img;
                        this.els.srcCanvas.width = img.width;
                        this.els.srcCanvas.height = img.height;
                        this.els.srcCtx.imageSmoothingEnabled = false;
                        this.redrawSource();
                    } else {
                        // Carregar para Editar (Destino)
                        this.initDest(img.width, img.height); // Redimensiona destino para caber a imagem
                        this.els.destCtx.drawImage(img, 0, 0);
                        this.saveHistory();
                        this.status("Tileset base carregado para edi√ß√£o.");
                    }
                };
                img.src = URL.createObjectURL(input.files[0]);
                input.value = ''; // Reseta input
            },

            saveHistory() {
                const data = this.els.destCtx.getImageData(0, 0, this.els.destCanvas.width, this.els.destCanvas.height);
                this.state.history = this.state.history.slice(0, this.state.historyIndex + 1);
                this.state.history.push(data);
                if (this.state.history.length > 20) this.state.history.shift();
                else this.state.historyIndex++;
            },

            undo() {
                if(this.state.historyIndex > 0) {
                    this.state.historyIndex--;
                    const data = this.state.history[this.state.historyIndex];
                    this.els.destCtx.putImageData(data, 0, 0);
                    this.redrawDest();
                    this.status("Desfeito.");
                }
            },

            download() {
                const temp = document.createElement('canvas');
                temp.width = this.els.destCanvas.width;
                temp.height = this.els.destCanvas.height;
                // Pega dados brutos do hist√≥rico (sem fantasma)
                temp.getContext('2d').putImageData(this.state.history[this.state.historyIndex], 0, 0);
                
                const link = document.createElement('a');
                link.download = `Edit_Tileset_${Date.now()}.png`;
                link.href = temp.toDataURL();
                link.click();
            },

            setZoom(val) {
                this.state.zoom = val;
                this.els.srcCanvas.style.transform = `scale(${val})`;
                this.els.destCanvas.style.transform = `scale(${val})`;
                const m = (val-1)*50;
                this.els.srcWrapper.style.padding = `${m}px`;
                this.els.destWrapper.style.padding = `${m}px`;
            },

            status(msg) { document.getElementById('statusText').innerText = msg; }
        };

        App.init();
    </script>
</body>
</html>