<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>RPG Maker Studio - Overlay Fix</title>
    <style>
        body { background: #181818; color: #ccc; font-family: sans-serif; margin: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; user-select: none; }
        
        /* Toolbar */
        .tools { background: #202020; padding: 10px; display: flex; gap: 10px; border-bottom: 1px solid #333; align-items: center; flex-wrap: wrap;}
        .sep { width: 1px; height: 30px; background: #333; margin: 0 5px; }
        
        label { font-size: 10px; font-weight: bold; color: #666; text-transform: uppercase; display: block; }
        
        select, input { background: #333; border: 1px solid #444; color: white; padding: 4px; border-radius: 3px; }
        input[type="number"] { width: 40px; text-align: center; }
        
        button { background: #333; color: #ddd; border: 1px solid #444; padding: 5px 10px; cursor: pointer; border-radius: 3px; display: flex; align-items: center; gap: 5px; font-size: 12px;}
        button:hover { background: #444; }
        
        .btn-blue { background: #007acc; border-color: #005a9e; color: white; }
        .btn-purple { background: #6a00ff; border-color: #5100c4; color: white; }

        /* Layout */
        .main { flex: 1; display: flex; overflow: hidden; }
        .panel { flex: 1; display: flex; flex-direction: column; border-right: 2px solid #333; min-width: 0; }
        .header { background: #252526; padding: 5px 10px; font-size: 11px; font-weight: bold; color: #888; display: flex; justify-content: space-between; border-bottom: 1px solid #333; }
        
        /* O segredo da arquitetura Overlay */
        .viewport { flex: 1; overflow: auto; background: #111; display: grid; place-items: center; position: relative; }
        #wrapDest { position: relative; } /* Container para o overlay */
        #cDestOverlay { position: absolute; top: 0; left: 0; pointer-events: none; } /* O Overlay fica por cima e n√£o recebe cliques */
        
        canvas { image-rendering: pixelated; box-shadow: 0 0 20px #000; display: block; }
        .bg-check {
            background-image: linear-gradient(45deg, #222 25%, transparent 25%), linear-gradient(-45deg, #222 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #222 75%), linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px;
        }

        .bar { background: #007acc; color: white; padding: 2px 10px; font-size: 11px; display: flex; justify-content: space-between; font-weight: bold; }
        .hide { display: none; }
    </style>
</head>
<body>

    <div class="tools">
        <div>
            <label>Modo</label>
            <select id="selMode">
                <option value="iconset">Iconset (24px)</option>
                <option value="tileset">Tileset (32px)</option>
                <option value="char">Charset</option>
                <option value="faceset">Faceset</option>
                <option value="free">Livre</option>
            </select>
        </div>
        <div class="sep"></div>
        <div>
            <label>Grid (W/H)</label>
            <div style="display:flex; gap:2px">
                <input type="number" id="inpW" value="24">
                <input type="number" id="inpH" value="24">
            </div>
        </div>
        <div style="margin-left: auto; display:flex; gap: 10px;">
            <button class="btn-purple" onclick="$('fConv').click()">‚ö° Importar MV/MZ</button>
            <div class="sep"></div>
            <button onclick="$('fSrc').click()">üìÇ Abrir Origem</button>
            <button onclick="$('fDest').click()">‚úèÔ∏è Editar Base</button>
            <button class="btn-blue" onclick="save()">üíæ Salvar Limpo</button>
            <input type="file" id="fSrc" class="hide" accept="image/*">
            <input type="file" id="fDest" class="hide" accept="image/*">
            <input type="file" id="fConv" class="hide" accept="image/*">
        </div>
    </div>

    <div class="main">
        <div class="panel">
            <div class="header"><span>ORIGEM</span> <span style="color:#007acc">Segure & Arraste</span></div>
            <div class="viewport bg-check" id="wrapSrc">
                <canvas id="cSrc" style="cursor: crosshair;"></canvas>
            </div>
        </div>
        <div class="panel">
            <div class="header"><span>DESTINO</span> <span>Esq: Colar | Dir: Apagar</span></div>
            <div class="viewport bg-check" id="wrapDest">
                <canvas id="cDest" style="cursor: crosshair;"></canvas>
                <canvas id="cDestOverlay"></canvas> <!-- NOVO CANVAS OVERLAY -->
            </div>
        </div>
    </div>
    <div class="bar">
        <span id="log">Overlay Architecture. Pronto para salvar sem marcas.</span>
        <span id="pos">0, 0</span>
    </div>

    <script>
        const $ = id => document.getElementById(id);
        let grid = { w: 24, h: 24 };
        let state = { zoom: 1, selecting: false, pStart: {x:0, y:0}, rect: {x:0, y:0, w:0, h:0}, clip: null, history: [], hIdx: -1 };

        const cSrc = $('cSrc'), cDest = $('cDest'), cOver = $('cDestOverlay');
        const ctxS = cSrc.getContext('2d', { willReadFrequently: true });
        const ctxD = cDest.getContext('2d', { willReadFrequently: true });
        const ctxO = cOver.getContext('2d'); // Contexto do Overlay
        let imgS = null;

        ctxS.imageSmoothingEnabled = false;
        ctxD.imageSmoothingEnabled = false;
        ctxO.imageSmoothingEnabled = false;

        // --- Init & UI ---
        function init() {
            $('selMode').onchange = function() {
                let m = this.value, w=32, h=32;
                if(m === 'iconset') { w=24; h=24; }
                if(m === 'faceset') { w=96; h=96; }
                if(m === 'free') { w=1; h=1; }
                $('inpW').value = w; $('inpH').value = h;
                updateGrid();
            };
            $('inpW').onchange = updateGrid; $('inpH').onchange = updateGrid;

            // Inicia com Iconset por causa da imagem do user
            resizeDest(24*16, 24*20); 
        }
        
        function updateGrid() {
            grid.w = parseInt($('inpW').value) || 24; grid.h = parseInt($('inpH').value) || 24;
            drawSrc();
        }

        // --- Desenho ---
        function drawSrc() {
            if(!imgS) return;
            ctxS.clearRect(0,0, cSrc.width, cSrc.height);
            ctxS.drawImage(imgS, 0, 0);
            ctxS.beginPath(); ctxS.strokeStyle = 'rgba(255,255,255,0.2)';
            for(let x=0; x<=cSrc.width; x+=grid.w) { ctxS.moveTo(x,0); ctxS.lineTo(x,cSrc.height); }
            for(let y=0; y<=cSrc.height; y+=grid.h) { ctxS.moveTo(0,y); ctxS.lineTo(cSrc.width,y); }
            ctxS.stroke();
            if(state.rect.w > 0) {
                ctxS.strokeStyle = '#00e5ff'; ctxS.lineWidth = 2; ctxS.fillStyle = 'rgba(0, 122, 204, 0.3)';
                ctxS.fillRect(state.rect.x, state.rect.y, state.rect.w, state.rect.h);
                ctxS.strokeRect(state.rect.x, state.rect.y, state.rect.w, state.rect.h);
            }
        }

        // AGORA DESENHA APENAS NO OVERLAY TRANSPARENTE
        function drawOverlay(gx, gy) {
            ctxO.clearRect(0,0, cOver.width, cOver.height);
            if(state.clip && gx !== undefined) {
                ctxO.save();
                ctxO.globalAlpha = 0.7;
                ctxO.drawImage(state.clip, gx, gy);
                ctxO.strokeStyle = '#00e5ff';
                ctxO.strokeRect(gx, gy, state.rect.w, state.rect.h);
                ctxO.restore();
            }
        }

        // --- Mouse Origem ---
        cSrc.onmousedown = e => {
            if(!imgS) return;
            state.selecting = true;
            let p = getPos(cSrc, e);
            state.pStart = p;
            state.rect = { x: p.x, y: p.y, w: grid.w, h: grid.h };
            drawSrc();
        };
        cSrc.onmousemove = e => {
            if(!state.selecting) return;
            let p = getPos(cSrc, e);
            let x = Math.min(state.pStart.x, p.x), y = Math.min(state.pStart.y, p.y);
            let w = Math.abs(p.x - state.pStart.x) + grid.w, h = Math.abs(p.y - state.pStart.y) + grid.h;
            state.rect = {x, y, w, h};
            drawSrc();
        };
        window.onmouseup = () => {
            if(state.selecting) {
                state.selecting = false;
                ctxS.drawImage(imgS, 0, 0);
                let data = ctxS.getImageData(state.rect.x, state.rect.y, state.rect.w, state.rect.h);
                drawSrc();
                createImageBitmap(data).then(bmp => { state.clip = bmp; log(`Copiado: ${state.rect.w}x${state.rect.h}`); });
            }
        };

        // --- Mouse Destino ---
        cDest.onmousemove = e => {
            let p = getPos(cDest, e);
            $('pos').innerText = `${p.x}, ${p.y}`;
            drawOverlay(p.x, p.y); // Apenas atualiza o overlay
        };
        cDest.onmouseleave = () => ctxO.clearRect(0,0,cOver.width, cOver.height);

        cDest.onmousedown = e => {
            let p = getPos(cDest, e);
            
            // A√ß√µes afetam apenas o canvas de DADOS (ctxD)
            if(e.button === 0 && state.clip) {
                ctxD.drawImage(state.clip, p.x, p.y);
                pushHistory();
            } else if(e.button === 2) {
                ctxD.clearRect(p.x, p.y, state.rect.w || grid.w, state.rect.h || grid.h);
                pushHistory();
            }
        };
        cDest.oncontextmenu = e => e.preventDefault();

        // --- Helpers ---
        function getPos(c, e) {
            let r = c.getBoundingClientRect();
            let rx = e.clientX - r.left, ry = e.clientY - r.top;
            return { x: Math.floor(rx/grid.w)*grid.w, y: Math.floor(ry/grid.h)*grid.h };
        }
        function resizeDest(w, h) {
            cDest.width = cOver.width = w;
            cDest.height = cOver.height = h;
            ctxD.imageSmoothingEnabled = false;
            pushHistory();
        }
        function pushHistory() {
            let data = ctxD.getImageData(0, 0, cDest.width, cDest.height);
            state.history = state.history.slice(0, state.hIdx + 1);
            state.history.push(data);
            if(state.history.length > 20) state.history.shift(); else state.hIdx++;
        }
        function undo() {
            if(state.hIdx > 0) {
                state.hIdx--;
                ctxD.putImageData(state.history[state.hIdx], 0, 0);
                log("Desfeito.");
            }
        }
        function log(msg) { $('log').innerText = msg; }

        // --- Arquivos ---
        $('fSrc').onchange = function() { loadImg(this, true); };
        $('fDest').onchange = function() { loadImg(this, false); };
        $('fConv').onchange = function() {
            if(!this.files[0]) return;
            let img = new Image();
            img.onload = () => {
                let tw = Math.floor(img.width * (2/3)), th = Math.floor(img.height * (2/3));
                let tmp = document.createElement('canvas'); tmp.width = tw; tmp.height = th;
                let tCtx = tmp.getContext('2d');
                tCtx.imageSmoothingEnabled = true; tCtx.imageSmoothingQuality = 'high';
                tCtx.drawImage(img, 0, 0, tw, th);
                let cImg = new Image();
                cImg.onload = () => { imgS = cImg; cSrc.width = tw; cSrc.height = th; ctxS.imageSmoothingEnabled = false; drawSrc(); log("Convertido e Carregado."); };
                cImg.src = tmp.toDataURL();
            };
            img.src = URL.createObjectURL(this.files[0]); this.value = '';
        };
        function loadImg(inp, isSrc) {
            if(!inp.files[0]) return;
            let img = new Image();
            img.onload = () => {
                if(isSrc) { imgS = img; cSrc.width = img.width; cSrc.height = img.height; ctxS.imageSmoothingEnabled = false; drawSrc(); }
                else { resizeDest(img.width, img.height); ctxD.drawImage(img, 0, 0); pushHistory(); }
            };
            img.src = URL.createObjectURL(inp.files[0]); inp.value = '';
        }
        function save() {
            let t = document.createElement('canvas'); t.width = cDest.width; t.height = cDest.height;
            // Salva o √∫ltimo estado LIMPO do hist√≥rico
            t.getContext('2d').putImageData(state.history[state.hIdx], 0, 0);
            let a = document.createElement('a'); a.download = 'recurso_limpo.png'; a.href = t.toDataURL(); a.click();
        }

        init();
    </script>
</body>
</html>
